# monitor-server-logs

## プログラムの実行方法

本リポジトリの構成は以下のとおり。

![constitution](https://user-images.githubusercontent.com/86135975/127794940-fcfba8f2-4526-4fbd-9c48-23ff1538ac48.png)

実行方法は

カレントディレクトリを上図のrootにした状態で以下のコマンドを叩くことで実行することができる。

```bash
python Answers/answer_1.py
```

監視するログファイルはLogDataの中にまとめてある。

ログファイルは各answer.pyのmain関数にて読み込みが行われている。ファイルの指定はここに直接書き込む仕様である。


## 設問１

### アルゴリズム

- ログファイルを上から一行ずつ読み込み、タイムアウトの目印である'-'を探す。判定方法は応答時間をint型にキャストできるか。
- '-'を見つけたらその確認時間とサーバアドレスを紐づけて記録。
- その後の走査続け、**応答がある** かつ **タイムアウトしている記録がある**サーバを見つけたらその期間を出力する。2.で記録したものはこのタミングで破棄。
- 走査が終了したらタイムアウトの記録が破棄されていないものを出力。これはいまも復旧が確認されていないサーバを表している。

### 出力方法

出力は設問4まで通して使えるformatter.pyを作成した。

これは以下の３つの関数を持つ

- format_datetime

    YYYMMDDhhmmssからYYYY-MM-DD hh:mm:ssの文字列に変換を行う関数

- format_log

    サーバアドレス、故障の開始時間、返ってくるpingを投げた時間、その応答時間を引数に持つ関数。pingを投げた時間と応答時間を足したものを終了時間とする。第５引数は設問３で使用する。

- format_still

    タイムアウトのフラグ立っているが終了時間が存在しないケースで呼ばれる。

### 仕様

出力が終了時間について昇順になっている。開始時間について並んでいるほうが見やすいかもしれない。しかし、ログを上から見ながら出力していくには、終了時間が決定したタイミングで出力せざるを得ない。リアルタイム性と見やすさを天秤にかけたところ今回のプログラムの用途を鑑み、リアルタイム性を優先した。

### 実行例

```bash
python Answers/answer_1.py
```

により実行。監視するファイルはsample1.txtとする。

入力

---

20201019133124,10.20.30.1/16,2<br>
20201019133125,10.20.30.2/16,1<br>
20201019133134,192.168.1.1/24,10<br>
20201019133135,192.168.1.2/24,-<br>
20201019133224,10.20.30.1/16,522<br>
20201019133225,10.20.30.2/16,1<br>
20201019133234,192.168.1.1/24,-<br>
20201019133235,192.168.1.2/24,15<br>
20201019133324,10.20.30.1/16,2<br>
20201019133325,10.20.30.2/16,2<br>

---

出力

---

192.168.1.2/24 :   2020-10-19 13:31:35   ~    2020-10-19 13:32:35.015<br>
192.168.1.1/24 :   2020-10-19 13:32:34   ~

---

### 検証

出力が正しいか検証を行う。

入力のうちタイムアウトが起こっているのは太線の行である。

192.168.1.2/24のサーバはその後下線の行で応答を確認している。

つまり2020-10-19 13:31:35 から下線の行の2020-10-19 13:32:35にその応答時間15msを足した時間まで故障期間と見なすことができる。よって出力一行目は正しい。

192.168.1.1/24のサーバはタイムアウト後応答がない。

よって現在も故障期間とみなすことができ、こちらも出力2行目とマッチする。

20201019133124,10.20.30.1/16,2<br>
20201019133125,10.20.30.2/16,1<br>
20201019133134,192.168.1.1/24,10<br>
**20201019133135,192.168.1.2/24,-**<br>
20201019133224,10.20.30.1/16,522<br>
20201019133225,10.20.30.2/16,1<br>
**20201019133234,192.168.1.1/24,-**<br>
20201019133235,192.168.1.2/24,15<br>
20201019133324,10.20.30.1/16,2<br>
20201019133325,10.20.30.2/16,2<br>

他にタイムアウトが起きている箇所はないため、今回のテストケースでは正しい出力がでたと言える。


## 設問２

### アルゴリズム

- 設問１のコードにサーバアドレスとタイムアウトの回数を紐づいたdictionaryを追加する。
- タイムアウトを連続で踏むと回数が加算される
- タイムアウトのフラグがたった状態で応答があるとタイムアウトの回数を確認しNより多い場合出力する。いずれにせよ応答を確認したタイミングで回数とフラグを破棄する。
- 終了時間がないものもその時点でN回を超えているなら出力する。

### パラメータの受け取り方

今回Nをプログラムから受け取る手順がある。ここでは以下の関数の先頭でinput()を使用し受け取った。

```python
if __name__ == '__main__':
	N = int(input('故障とみなすタイムアウトの回数：')) 
```

### 実行例

```bash
python Answers/answer_2.py
```

により実行。監視するファイルはsample2.txtとし、N=3で実行した。

入力

---

20201019133124,10.20.30.1/16,2<br>
20201019133125,10.20.30.2/16,-<br>
20201019133134,192.168.1.1/24,10<br>
20201019133135,192.168.1.2/24,-<br>
20201019133224,10.20.30.1/16,-<br>
20201019133225,10.20.30.2/16,1<br>
20201019133234,192.168.1.1/24,8<br>
20201019133235,192.168.1.2/24,15<br>
20201019133324,10.20.30.1/16,-<br>
20201019133325,10.20.30.2/16,2<br>
20201019133334,192.168.1.1/24,8<br>
20201019133335,192.168.1.2/24,15<br>
20201019133424,10.20.30.1/16,-<br>
20201019133425,10.20.30.2/16,1<br>
20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5<br>
20201019133524,10.20.30.1/16,522<br>
20201019133525,10.20.30.2/16,1<br>
20201019133534,192.168.1.1/24,-<br>
20201019133535,192.168.1.2/24,-<br>

---

出力

---

10.20.30.1/16 : 2020-10-19 13:32:24 ~ 2020-10-19 13:35:24.522

---

### 検証

今回も入力のタイムアウトを太字にする。

---

20201019133124,10.20.30.1/16,2<br>
**20201019133125,10.20.30.2/16,-**<br>
20201019133134,192.168.1.1/24,10<br>
**20201019133135,192.168.1.2/24,-<br>
20201019133224,10.20.30.1/16,-**<br>
20201019133225,10.20.30.2/16,1<br>
20201019133234,192.168.1.1/24,8<br>
20201019133235,192.168.1.2/24,15<br>
**20201019133324,10.20.30.1/16,-**<br>
20201019133325,10.20.30.2/16,2<br>
20201019133334,192.168.1.1/24,8<br>
20201019133335,192.168.1.2/24,15<br>
**20201019133424,10.20.30.1/16,-**<br>
20201019133425,10.20.30.2/16,1<br>
20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5<br>
20201019133524,10.20.30.1/16,522<br>
20201019133525,10.20.30.2/16,1<br>
**20201019133534,192.168.1.1/24,-**<br>
**20201019133535,192.168.1.2/24,-**<br>

---

少し見通しが悪いためサーバごとに並び替えて考える。

---

20201019133124,10.20.30.1/16,2<br>
**20201019133224,10.20.30.1/16,-**<br>
**20201019133324,10.20.30.1/16,-**<br>
**20201019133424,10.20.30.1/16,-**<br>
20201019133524,10.20.30.1/16,522<br>

**20201019133125,10.20.30.2/16,-**<br>
20201019133225,10.20.30.2/16,1<br>
20201019133325,10.20.30.2/16,2<br>
20201019133425,10.20.30.2/16,1<br>
20201019133525,10.20.30.2/16,1<br>

20201019133134,192.168.1.1/24,10<br>
20201019133234,192.168.1.1/24,8<br>
20201019133334,192.168.1.1/24,8<br>
20201019133434,192.168.1.1/24,10<br>
**20201019133534,192.168.1.1/24,-**<br>

**20201019133135,192.168.1.2/24,-**<br>
20201019133235,192.168.1.2/24,15<br>
20201019133335,192.168.1.2/24,15<br>
20201019133434,192.168.1.1/24,10<br>
****20201019133435,192.168.1.2/24,5<br>
**20201019133535,192.168.1.2/24,-**<br>

---

ここで3回以上連続でタイムアウトが起きているのは10.20.30.1/16のみである。

さらに開始時間は2020-10-19 13:32:24

終了時間は2020-10-19 13:35:24.522

というように出力も正しいことがわかる。


## 設問３

### 方針

過負荷状態かを調べるときに以下の二つの方針が思う浮かんだ。

- タイムアウトを応答時間が十分大きいものとして考える
- タイムアウトは過負荷状態とは別の問題だと考え切り離して考える。

今回自分は後者の方針を選択した。具体的なポイントは以下のふたつ。

- タイムアウトが起きた時その段階で平均がtを越えていたら出力する。
- タイムアウトの次は１から平均を求めて判定する。

### アルゴリズム

- サーバアドレスごとに最大mの配列を作る。(recent_logs_by_sa)

    (配列の要素は**確認時間**と**応答時間**を**キー**とするdictionary(recent_response_time))

- サーバアドレスごとに応答時間の合計を記録する。
- タイムアウトでない場合

    recent_logs_by_asに確認時間と応答時間を記録。

    recent_response_timeに応答時間を加算

    ログの数がmを超えたら最も古いものを削除

    recent_response_timeからその応答時間を減算

    - recent_response_timeとrecent_logs_by_saの長さから直前m回の平均値を求めtと比較。

        →    t以上の場合は過負荷の記録をつける。

        →    t以下の場合は過負荷の記録があるなら出力

- タイムアウトが起きた時

    そのサーバアドレスに過負荷の記録があるならそれまでの記録を出力

    recent_response_timeとrecent_logs_by_saを初期化(削除)

    ### 出力

    今回はタイムアウトと過負荷状態のふたつの出力が混ざるため、各行の最後にタイムアウトか過負荷状態かを出力する仕様にした。

### 実行例

入力 N = 1 m = 2 t = 9

---

20201019133124,10.20.30.1/16,2<br>
20201019133125,10.20.30.2/16,-<br>
20201019133134,192.168.1.1/24,10<br>
20201019133135,192.168.1.2/24,-<br>
20201019133224,10.20.30.1/16,-<br>
20201019133225,10.20.30.2/16,1<br>
20201019133234,192.168.1.1/24,8<br>
20201019133235,192.168.1.2/24,15<br>
20201019133324,10.20.30.1/16,-<br>
20201019133325,10.20.30.2/16,2<br>
20201019133334,192.168.1.1/24,8<br>
20201019133335,192.168.1.2/24,15<br>
20201019133424,10.20.30.1/16,-<br>
20201019133425,10.20.30.2/16,1<br>
20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5<br>
20201019133524,10.20.30.1/16,522<br>
20201019133525,10.20.30.2/16,1<br>
20201019133534,192.168.1.1/24,-<br>
20201019133535,192.168.1.2/24,-<br>

---

出力

---

10.20.30.2/16  :   2020-10-19 13:31:25   ~    2020-10-19 13:32:25.001   タイムアウト<br>
192.168.1.1/24 :   2020-10-19 13:31:34   ~    2020-10-19 13:32:34.008   過負荷状態<br>
192.168.1.2/24 :   2020-10-19 13:31:35   ~    2020-10-19 13:32:35.015   タイムアウト<br>
10.20.30.1/16  :   2020-10-19 13:32:24   ~    2020-10-19 13:35:24.522   タイムアウト<br>
192.168.1.2/24 :   2020-10-19 13:32:35   ~    2020-10-19 13:35:35.0     過負荷(TO前)<br>
192.168.1.1/24 :   2020-10-19 13:35:34   ~                              タイムアウト<br>
192.168.1.2/24 :   2020-10-19 13:35:35   ~                              タイムアウト<br>
10.20.30.1/16  :   2020-10-19 13:35:24   ~                              過負荷状態

---

### 検証

今回もサーバごとに並び替えて検証する。

直前3回の平均応答時間が9秒より大きくなるものを太くしていく。

---

20201019133124,10.20.30.1/16,2<br>
20201019133224,10.20.30.1/16,-<br>
20201019133324,10.20.30.1/16,-<br>
20201019133424,10.20.30.1/16,-<br>
**20201019133524,10.20.30.1/16,522**<br>

20201019133125,10.20.30.2/16,-<br>
20201019133225,10.20.30.2/16,1<br>
20201019133325,10.20.30.2/16,2<br>
20201019133425,10.20.30.2/16,1<br>
20201019133525,10.20.30.2/16,1<br>

**20201019133134,192.168.1.1/24,10**<br>
20201019133234,192.168.1.1/24,8<br>
20201019133334,192.168.1.1/24,8<br>
20201019133434,192.168.1.1/24,10<br>
20201019133534,192.168.1.1/24,-<br>

20201019133135,192.168.1.2/24,-<br>
**20201019133235,192.168.1.2/24,15**<br>
**20201019133335,192.168.1.2/24,15**<br>
**20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5**<br>
20201019133535,192.168.1.2/24,-<br>

---

これらの通り太くしたところの確認時間と出力の過負荷状態の開始時間、

太字が終わった次の確認時間+応答時間が出力の過負荷状態の終了時間

太字の後ろにタイムアウトが来るとその確認時間が終了時間に対応していることがわかる。

以上より望んだ出力が行われたと言える。



## 設問４

設問２のプログラムを拡張して実装した。server_addressをネットワーク部のみのものにすればあとは同じなので、その変換部分のみ詳細を記述する。

### アルゴリズム

それぞれがどのネットワークに所属しているか、すなわちサーバのアドレスのどこまでがネットワーク部であるかはネットワークプレフィックスを見ればわかる。この値は32bitで表されるサーバアドレスの上位何bitがネットワーク部であるかを示している。ネットワーク部を抽出するのに以下の手順を辿った。

- 各オクテットの値を2進数に直し、それぞれ8bitになるように０埋め
- 全体をリバース し下から32-プレフィックスの部分のみ残す。
- 0埋めを行い32bitに直す
- 8bitごとに区切り10進数に変換
- 最後に**.**をはさみながら繋ぎ合わせる。

こうしてサーバアドレスをネットワーク部のアドレスに変換できたので、これを使用し設問２の関数にかければよい。

### 実行例1

入力　N = 1

---

20201019133124,10.20.30.1/16,2<br>
20201019133125,10.20.30.2/16,-<br>
20201019133134,192.168.1.1/24,10<br>
20201019133135,192.168.1.2/24,-<br>
20201019133224,10.20.30.1/16,-<br>
20201019133225,10.20.30.2/16,1<br>
20201019133234,192.168.1.1/24,8<br>
20201019133235,192.168.1.2/24,15<br>
20201019133324,10.20.30.1/16,-<br>
20201019133325,10.20.30.2/16,2<br>
20201019133334,192.168.1.1/24,8<br>
20201019133335,192.168.1.2/24,15<br>
20201019133424,10.20.30.1/16,-<br>
20201019133425,10.20.30.2/16,1<br>
20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5<br>
20201019133524,10.20.30.1/16,522<br>
20201019133525,10.20.30.2/16,1<br>
20201019133534,192.168.1.1/24,-<br>
20201019133535,192.168.1.2/24,-<br>

---

出力

---

10.20.0.0      :   2020-10-19 13:31:25   ~    2020-10-19 13:32:25.001<br>
192.168.1.0    :   2020-10-19 13:31:35   ~    2020-10-19 13:32:34.008<br>
10.20.0.0      :   2020-10-19 13:33:24   ~    2020-10-19 13:33:25.002<br>
10.20.0.0      :   2020-10-19 13:34:24   ~    2020-10-19 13:34:25.001<br>
192.168.1.0    :   2020-10-19 13:35:34   

---

### 検証１

今回はサブネットごとに仕分けを行う。

10.20.30.1/16 10.20.30.2/16 のネットワーク部は両方**10.20.0.0**<br>

192.168.1.1/24 192.168.1.2/24のネットワーク部は両方**192.168.1.0**<br>

であるため２種類に分けることができる。

タイムアウトが起こっているのは太字の部分

---

20201019133124,10.20.30.1/16,2<br>
**20201019133125,10.20.30.2/16,-**<br>
**20201019133224,10.20.30.1/16,-**<br>
20201019133225,10.20.30.2/16,1<br>
**20201019133324,10.20.30.1/16,-**<br>
20201019133325,10.20.30.2/16,2<br>
**20201019133424,10.20.30.1/16,-**<br>
20201019133425,10.20.30.2/16,1<br>
20201019133524,10.20.30.1/16,522<br>
20201019133525,10.20.30.2/16,1<br>

20201019133134,192.168.1.1/24,10<br>
**20201019133135,192.168.1.2/24,-**<br>
20201019133234,192.168.1.1/24,8<br>
20201019133235,192.168.1.2/24,15<br>
20201019133334,192.168.1.1/24,8<br>
20201019133335,192.168.1.2/24,15<br>
20201019133434,192.168.1.1/24,10<br>
20201019133435,192.168.1.2/24,5<br>
**20201019133534,192.168.1.1/24,-<br>
20201019133535,192.168.1.2/24,-**<br>

---

こちらの５箇所も出力と対応している。

### 実行例2

今度は同じ入力に対してN=3と設定する。

---

出力

---

---

### 検証２

出力はなしだった。たしかに上の表を見ても3回連続太字にはなっていないためこの結果は正しい。

設問２では**10.20.30.1のサーバ**で3連続タイムアウトを検知した。

今回の実験から**10.20.0.0**のサブネットは3回連続タイムアウトを起こしていないことがわかった。

このことから（**10.20.30.2**が応答していることからも自明だが）故障しているのはサブネットのスイッチではなく、**10.20.30.1**のサーバだろうと推測できる。
